## 課題2-1

【結論】
分析のみの用途でも履歴データをデータベースに保存しておく必要はある
ログテーブルを作成して、Elastic SearchやBigQuryに保存しておく
例えば、以下のように元データテーブルと同じカラム + ログ用の作成日を持つ。更新があったものをどんどん放り込んでいきます。最新かどうかは作成日で判断します。

| id  | item_id | price  | log_created_at      |
| --- | ------- | ------ | ------------------- |
| 1   | 1       | 1,100  | 2018-11-10 12:00:00 |
| 2   | 2       | 2,000  | 2018-11-10 12:01:00 |
| 3   | 3       | 11,000 | 2018-11-10 12:02:00 |
| 4   | 3       | 10,500 | 2018-11-15 12:00:00 |
| 5   | 1       | 1,000  | 2018-11-18 11:00:00 |
| 6   | 3       | 10,000 | 2018-20-10 13:00:00 |

【参考】
https://user-first.ikyu.co.jp/entry/history-table

## 課題2-2

課題1で履歴テーブルを作成する方法で行ったので、1つのテーブルで管理する方法で行います。

たとえば、version=2 を現在の状態に戻したい場合は、現行のバージョン（例えば version=3）の is_current を false にし、version=2 の is_current を true に変更します。
これにより、ユーザーは常に is_current=true の行を最新として参照できます。


**articles**

| キー | カラム名    | データ型    | 制約     | 説明 |
| ---- | ----------- | ----------- | -------- | ---- |
| PK   | article_id  | int         | NOT NULL |      |
|      | title       | VARCHAR(20) | NOT NULL |      |
|      | description | text        | NOT NULL |      |
|      | is_current  | boolean     | NOT NULL |      |
| PK   | version     | INT         | NOT NULL |      |
|      | created_at  | DATETTIME   | NOT NULL |      |
|      | updated_at  | DATETTIME   | NOT NULL |      |

```mermaid
erDiagram 
  articles {
      INT article_id PK 
      VARCHAR title
      TEXT description
      BOOLEAN is_current
      DATETIME createdAt
      DATETIME updatedAt
  }
```

メリット
- 使用するテーブルが一つなので, テーブル変更時に問題が起こりにくい.

デメリット
- リレーションがある場合、他のテーブルも更新処理が必要になる
- 更新時のクエリの発行が面倒

【変更点】
- is_currentフラグを用意して過去履歴に戻れるように変更しました
