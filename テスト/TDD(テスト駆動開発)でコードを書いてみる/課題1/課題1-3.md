## １．TDD と BDD の主な違い

| 項目 | TDD | BDD |
|------|-----|-----|
| **フォーカス** | **コード**の単体テスト（ユニットテスト） | **振る舞い（ビジネスの動作）**の受け入れテスト／仕様テスト（シナリオテスト） |
| **言語レベル** | 技術者向け（テストフレームワークの API） | ドメイン知識に即した自然言語（Given-When-Then 形式など）、Ubiquitous Language |
| **スコープ** | メソッド／クラス単位 | 機能（Feature）単位、シナリオ（Scenario）単位 |
| **コミュニケーション** | 開発者 ⇄ コード | 開発者 ⇄ テスター ⇄ ビジネス／QA 間で"仕様"を共有 |
| **主なアウトプット** | テストコード、リファクタリング可能な設計 | ドキュメントとしてのシナリオ（仕様書）、自動化された受け入れテストコード |

* **TDD** は「まず失敗するユニットテストを書いて、通すための最小実装を行い、リファクタリングする（Red-Green-Refactor）」サイクルにより、**コードの健全性**と**設計の改善**を図ります。

* **BDD** では「まず振る舞い（ビジネス要件）のシナリオを書く」→「そのシナリオが自動で通る実装を書く」→「リファクタリング」で、**仕様の明文化**と**チーム間の共通理解**を図ります。

## ２．BDD が提唱された背景と解決したかった課題

### 提唱者

* **Dan North**（ThoughtWorks）によって 2006 年頃に提唱されました。

### 解決したかった問題

1. **TDD の"ユニット偏重"と仕様のブラックボックス化**

* TDD ではテストもコードレベル（メソッド単位）になりがちで、「このテストは何を保証しているのか」がテックサイド以外には伝わりにくい。

* 仕様変更時に「どのユニットテストを修正すれば要件に追従できるか」が不明瞭になる。

2. **開発者とビジネス／QA との認識ギャップ**

* テストコード（assert や mock）だけでは、非エンジニアがレビュー・承認しづらい。

* 要件の"振る舞い"ではなく、"内部実装"に引っ張られたテストケースになりやすい。

3. **テストのドキュメント性不足**

* TDD ではテストが増えるほどテストコードのメンテナンスも増え、仕様書としての可読性が低下しやすい。

* 自動テストが「チェックリスト」にならず、「誰が見ても仕様がわかる文書」として残らない。

### BDD がもたらしたソリューション

* **自然言語＋DSL（Given-When-Then）**

例：

Feature: 予約が完了する

Scenario: 宿泊プランを選択して予約する

Given 私はログイン済みのユーザーである

When 宿泊プラン「Deluxe」を選択して「予約する」をクリックする

Then 予約確認ページに「予約完了」と表示される

と書くことで、非エンジニアにも仕様が明確になる。

* **Outside-In（Outside-In TDD / Acceptance-Test-Driven Development）**

システム全体の **振る舞い** を先に書くことで、実装を「外→内」の順に設計。ビジネス要件からコード設計まで一貫した流れを実現。

* **Ubiquitous Language（ドメイン共通言語）** の徹底

ビジネス用語そのままのシナリオを書くことで、チーム内で用語の解釈ズレを防ぎ、ドメインモデル設計にも反映できる。
