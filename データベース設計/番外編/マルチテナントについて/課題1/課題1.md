### 解決方法
今回はDB側の視点から考察する

【解決方法】
RLSを活用する

**RLSとは？**
RLSは、テーブルの各行に対してアクセス制御ポリシーを設定する仕組みです

【具体的な方法】
RLSを有効にするには以下のように行う

> CREATE POLICY name ON table_name
>     [ FOR (command) ]
>     [ TO role_name [, ...] ]
>     [ USING ( using_expression ) ]
>     [ WITH CHECK ( check_expression ) ]

> name : RLSポリシーの名前です。テーブル毎にユニークである必要があります。
table_name : RLSポリシーを適用する対象のテーブル名です。
command : RLSポリシーが適用されるコマンドです。デフォルトは ALL で、全てのコマンドに適用されます。
role_name : RLSポリシーが適用されるロールです。 デフォルトはPUBLICで、すべてのロールに対してポリシーが適用されます。
using_expression : SELECT、 UPDATE、 DELETEの際にどの行が見えるか(可視性)をSQL条件式で指定します。
check_expression : テーブルに追加・更新される行に対し、 可視性の条件(USING句)とは異なるポリシーを使用したい場合に利用します。 INSERT、 UPDATEされたあとのレコードがこの条件式を満たすことを保証します。

今回の場合、すでにemployeeテーブルが作成されていると仮定して、以下のように行う

```
-- テーブルに対してRLSを有効化
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;

-- テナント情報を利用したポリシーを設定
CREATE POLICY tenant_policy ON employees
  USING (tenant_id = current_setting('app.current_tenant')::text);
```
app.current_tenantにテナントIDを、セットしておくだけで、各クエリが自動的にそのテナントの行に制限される。
たとえアプリケーション側でWHERE句の記述ミスがあった場合でも、DB側のRLSポリシーによって誤ったデータ漏洩が防止される

【メリット】
- アプリケーション層のミスをカバーできる
- テナントごとのアクセス制御を一元化できる

【参考資料】
https://zenn.dev/nstock/articles/multi-tenant-saas-using-rls
https://buildersbox.corp-sansan.com/entry/2021/05/10/110000
https://zenn.dev/rio_dev/articles/0896d01bc97e51
https://zenn.dev/loglass/articles/49af6c8d631240#rls%EF%BC%88row-level-security%EF%BC%89
